GobbletのAI

Gobbletのルール
駒は特大、大、中、小の４種類が3組
盤は4×4
プレイヤーは交互に手番がくる
初めは盤の上には駒がない
手番が来たら盤上の駒を動かすか、盤外にある駒を動かすことができる
ただし、盤外の駒の個数を特大、大、中、小それぞれc1, c2, c3, c4とすると、c1<=c2<=c3<=c4が常に成り立つ必要がある。
駒を動かすとき、駒をより小さい駒に被せることもできる
縦横斜めのいずれかの一列(4マス)を揃えることができたら勝利
駒を動かそうとしたら、相手の駒が下から出てきて一列を揃った場合は駒を動かした人が負け
下に駒がある駒を動かそうとして相手の駒が一列を揃った場合は負け

開発環境
Windows11 Home 64bit
Corei7-12700H
メモリ 16GB
Visual Studio 2022 Community(64bit) Ver 17.3.3

必敗の局面が存在する。
例
黒の手番、oを白, xを黒の特大として、
oxoo
oo
x x
o  o
(黒の特大以外は全部白の特大の下にある。黒の特大の下には白の駒がある)

深さ優先探索(局面メモ化有り, 局面やプレイヤーの対称性も利用)
普通のゴブレット(上述)の初期局面から開始。
depthは先後合わせて指した手数
cntはdepth_searchを呼び出した回数
cnt2はすでに現れた局面を調べた回数。cnt2!=(ループした回数)であることに注意。後日ループした回数は調べます。
mpは局面をメモ化する連想配列
mp sizeが調べた局面数
mp maxsizeを局面数が超えないようにしないといけない
考察も後日行います。
depth:1, cnt:65, cnt2:52, mp size:13, mp maxsize:192153584101141162
depth:2, cnt:803, cnt2:244, mp size:559, mp maxsize:192153584101141162
depth:3, cnt:18685, cnt2:8334, mp size:10351, mp maxsize:192153584101141162
depth:4, cnt:320908, cnt2:116983, mp size:203925, mp maxsize:192153584101141162
depth:5, cnt:1801730, cnt2:708977, mp size:1092753, mp maxsize:192153584101141162
depth:6, cnt:34631041, cnt2:14412282, mp size:20218759, mp maxsize:192153584101141162
depth:7, cnt:75525033, cnt2:35460929, mp size:40064104, mp maxsize:192153584101141162
depth:8<- メモリ使用量10GB強, 1時間以上動かしても終わらないため終了

1列も揃っていない局面数
4052027033585227491025
少なくとも一列は揃っている局面数
1920188066479887095376
物理的にあり得る局面数
5972215100065114586401

BOARD_SIZE = 4
PIECE_TYPE_COUNT = 3
PIECE_EACH_COUNT = 2
1列も揃っていない局面数
3106353738321
少なくとも一列は揃っている局面数
130840596936
物理的にあり得る局面数
3237194335257

BOARD_SIZE = 4
PIECE_TYPE_COUNT = 3
PIECE_EACH_COUNT = 2
1列も揃っていない局面数
1484813239
少なくとも一列は揃っている局面数
1396660728
物理的にあり得る局面数
2881473967

BOARD_SIZE = 5
PIECE_TYPE_COUNT = 3
PIECE_EACH_COUNT = 2
1列も揃っていない局面数
751674337179831
少なくとも一列は揃っている局面数
680011175520
物理的にあり得る局面数
752354348355351
